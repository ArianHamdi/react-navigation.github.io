"use strict";(self.webpackChunkreact_navigation_website_next=self.webpackChunkreact_navigation_website_next||[]).push([[24910],{84444:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>c,contentTitle:()=>r,default:()=>l,frontMatter:()=>o,metadata:()=>s,toc:()=>p});var i=n(85893),a=n(11151);const o={id:"static-typescript",title:"Configuring TypeScript with static API",sidebar_label:"Configuring TypeScript"},r=void 0,s={id:"static-typescript",title:"Configuring TypeScript with static API",description:"There are 2 steps to configure TypeScript with the static API:",source:"@site/versioned_docs/version-7.x/static-typescript.md",sourceDirName:".",slug:"/static-typescript",permalink:"/docs/7.x/static-typescript",draft:!1,unlisted:!1,editUrl:"https://github.com/react-navigation/react-navigation.github.io/edit/main/versioned_docs/version-7.x/static-typescript.md",tags:[],version:"7.x",frontMatter:{id:"static-typescript",title:"Configuring TypeScript with static API",sidebar_label:"Configuring TypeScript"},sidebar:"docs",previous:{title:"API Reference",permalink:"/docs/7.x/static-api-reference"},next:{title:"Authentication flow",permalink:"/docs/7.x/static-authentication"}},c={},p=[{value:"Navigator specific types",id:"navigator-specific-types",level:2},{value:"Nesting navigator using dynamic API",id:"nesting-navigator-using-dynamic-api",level:2}];function d(e){const t={a:"a",code:"code",h2:"h2",li:"li",ol:"ol",p:"p",pre:"pre",...(0,a.a)(),...e.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.p,{children:"There are 2 steps to configure TypeScript with the static API:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Each screen component needs to specify the type of the ",(0,i.jsx)(t.code,{children:"route.params"})," prop that it accepts. The ",(0,i.jsx)(t.code,{children:"StaticScreenProps"})," type makes it simpler:"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import type { StaticScreenProps } from '@react-navigation/native';\n\ntype Props = StaticScreenProps<{\n  username: string;\n}>;\n\nfunction ProfileScreen({ route }: Props) {\n  // ...\n}\n"})}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:["Generate the ",(0,i.jsx)(t.code,{children:"ParamList"})," type for the root navigator and specify it as the default type for the ",(0,i.jsx)(t.code,{children:"RootParamList"})," type:"]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"import type { StaticParamList } from '@react-navigation/native';\n\nconst HomeTabs = createBottomTabNavigator({\n  screens: {\n    Feed: FeedScreen,\n    Profile: ProfileScreen,\n  },\n});\n\nconst RootStack = createNativeStackNavigator({\n  screens: {\n    Home: HomeTabs,\n  },\n});\n\ntype RootStackParamList = StaticParamList<typeof RootStack>;\n\ndeclare global {\n  namespace ReactNavigation {\n    interface RootParamList extends RootStackParamList {}\n  }\n}\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This is needed to type-check the ",(0,i.jsx)(t.code,{children:"useNavigation"})," hook."]}),"\n",(0,i.jsx)(t.h2,{id:"navigator-specific-types",children:"Navigator specific types"}),"\n",(0,i.jsxs)(t.p,{children:["Generally we recommend using the default types for the ",(0,i.jsx)(t.code,{children:"useNavigation"})," prop to access the navigation object in a navigator agnostic manner. However, if you need to use navigator specific APIs, you need to manually annotate ",(0,i.jsx)(t.code,{children:"useNavigation"}),":"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:"type BottomTabParamList = StaticParamList<typeof BottomTabNavigator>;\ntype ProfileScreenNavigationProp = BottomTabNavigationProp<\n  BottomTabParamList,\n  'Profile'\n>;\n\n// ...\n\nconst navigation = useNavigation<ProfileScreenNavigationProp>();\n"})}),"\n",(0,i.jsxs)(t.p,{children:["This follows the same principle as the types described in ",(0,i.jsx)(t.a,{href:"/docs/7.x/typescript",children:"Type checking with TypeScript"}),"."]}),"\n",(0,i.jsxs)(t.p,{children:["Note that annotating ",(0,i.jsx)(t.code,{children:"useNavigation"})," this way not type-safe since we can't guarantee that the type you provided matches the type of the navigator."]}),"\n",(0,i.jsx)(t.h2,{id:"nesting-navigator-using-dynamic-api",children:"Nesting navigator using dynamic API"}),"\n",(0,i.jsx)(t.p,{children:"Consider the following example:"}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-js",children:'const Tab = createBottomTabNavigator();\n\nfunction HomeTabs() {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n\nconst RootStack = createStackNavigator({\n  Home: HomeTabs,\n});\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Here, the ",(0,i.jsx)(t.code,{children:"HomeTabs"})," component is defined using the dynamic API. This means that when we create the param list for the root navigator with ",(0,i.jsx)(t.code,{children:"StaticParamList<typeof RootStack>"}),", it won't know about the screens defined in the nested navigator. To fix this, we'd need to specify the param list for the nested navigator explicitly."]}),"\n",(0,i.jsxs)(t.p,{children:["This can be done by using the type of the ",(0,i.jsx)(t.code,{children:"route"})," prop that the screen component receives:"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-ts",children:'type HomeTabsParamList = {\n  Feed: undefined;\n  Profile: undefined;\n};\n\ntype HomeTabsProps = StaticScreenProps<\n  NavigatorScreenParams<HomeTabsParamList>\n>;\n\nfunction HomeTabs(_: HomeTabsProps) {\n  return (\n    <Tab.Navigator>\n      <Tab.Screen name="Feed" component={FeedScreen} />\n      <Tab.Screen name="Profile" component={ProfileScreen} />\n    </Tab.Navigator>\n  );\n}\n'})}),"\n",(0,i.jsxs)(t.p,{children:["Now, when using ",(0,i.jsx)(t.code,{children:"StaticParamList<typeof RootStack>"}),", it will include the screens defined in the nested navigator."]})]})}function l(e={}){const{wrapper:t}={...(0,a.a)(),...e.components};return t?(0,i.jsx)(t,{...e,children:(0,i.jsx)(d,{...e})}):d(e)}},11151:(e,t,n)=>{n.d(t,{Z:()=>s,a:()=>r});var i=n(67294);const a={},o=i.createContext(a);function r(e){const t=i.useContext(o);return i.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function s(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),i.createElement(o.Provider,{value:t},e.children)}}}]);